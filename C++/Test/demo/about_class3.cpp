/*----------------------------------------------------------------
// Copyright (C) MickelZhang
// License:MIT
// 文件名：about_class3.cpp
// 文件功能描述：类的多态和数据抽象
// 创建者：MickelZhang
// 时间：2020/12/22
// 修改人：
// 时间：
// 修改说明：
// 软件版本：VS2015
//----------------------------------------------------------------*/

/*
多态
按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。
C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。
Shape 类中的函数和虚函数的区别：
int area():
  调用函数 area() 被编译器设置为基类中的版本，这就是所谓的静态多态，或静态链接 - 函数调用在程序执行前就准备好了。
  有时候这也被称为早绑定，因为 area() 函数在程序编译期间就已经设置好了。
virtual int area():
  编译器看的是指针的内容，而不是它的类型。因此，由于 tri 和 rec 类的对象的地址存储在 *shape 中，所以会调用各自的 area() 函数。
  正如您所看到的，每个子类都有一个函数 area() 的独立实现。这就是多态的一般使用方式。
  有了多态，您可以有多个不同的类，都带有同一个名称但具有不同实现的函数，函数的参数甚至可以是相同的。
虚函数：
  虚函数 是在基类中使用关键字 virtual 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。
  我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或后期绑定。
纯虚函数：
  您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，
  但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。
  class Shape {
   protected:
      int width, height;
   public:
      Shape( int a=0, int b=0)
      {
         width = a;
         height = b;
      }
      // pure virtual function //纯虚函数
      virtual int area() = 0;
  };
  
数据抽象：
  数据抽象是指，只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。
  数据抽象是一种依赖于接口和实现分离的编程（设计）技术。
  让我们举一个现实生活中的真实例子，比如一台电视机，您可以打开和关闭、切换频道、调整音量、添加外部组件（如喇叭、录像机、DVD 播放器），
  但是您不知道它的内部实现细节，也就是说，您并不知道它是如何通过缆线接收信号，如何转换信号，并最终显示在屏幕上。
  因此，我们可以说电视把它的内部实现和外部接口分离开了，您无需知道它的内部实现原理，直接通过它的外部接口（比如电源按钮、遥控器、声量控制器）就可以操控电视。
  现在，让我们言归正传，就 C++ 编程而言，C++ 类为数据抽象提供了可能。
  它们向外界提供了大量用于操作对象数据的公共方法，也就是说，外界实际上并不清楚类的内部实现。
  例如，您的程序可以调用 sort() 函数，而不需要知道函数中排序数据所用到的算法。
  实际上，函数排序的底层实现会因库的版本不同而有所差异，只要接口不变，函数调用就可以照常工作。
访问标签强制抽象：
  在 C++ 中，我们使用访问标签来定义类的抽象接口。一个类可以包含零个或多个访问标签：
  使用公共标签定义的成员都可以访问该程序的所有部分。一个类型的数据抽象视图是由它的公共成员来定义的。
  使用私有标签定义的成员无法访问到使用类的代码。私有部分对使用类型的代码隐藏了实现细节。
  访问标签出现的频率没有限制。每个访问标签指定了紧随其后的成员定义的访问级别。
  指定的访问级别会一直有效，直到遇到下一个访问标签或者遇到类主体的关闭右括号为止。
数据抽象的好处：
数据抽象有两个重要的优势：
  1.类的内部受到保护，不会因无意的用户级错误导致对象状态受损。
  2.类实现可能随着时间的推移而发生变化，以便应对不断变化的需求，或者应对那些要求不改变用户级代码的错误报告。
  如果只在类的私有部分定义数据成员，编写该类的作者就可以随意更改数据。
  如果实现发生改变，则只需要检查类的代码，看看这个改变会导致哪些影响。
  如果数据是公有的，则任何直接访问旧表示形式的数据成员的函数都可能受到影响。
  
上面的类把数字相加，并返回总和。公有成员 addNum 和 getTotal 是对外的接口，用户需要知道它们以便使用类。
私有成员 total 是用户不需要了解的，但又是类能正常工作所必需的。
设计策略：
  抽象把代码分离为接口和实现。所以在设计组件时，必须保持接口独立于实现，这样，如果改变底层实现，接口也将保持不变。
  在这种情况下，不管任何程序使用接口，接口都不会受到影响，只需要将最新的实现重新编译即可

*/

/*-----------------------------------------------------------------
// 功能描述：Shape类的多态测试
// 用法：（也可以举例添加详细的使用方法，或者尽可能描述清楚）
// 作者：MickelZhang
// 日期：2020/12/18
// 修改人：MickelZhang 2020/12/12
// 记录：
// 修改人：
// 记录：
// 版本：
-----------------------------------------------------------------*/
class Shape {
   protected:
      int width, height;
   public:
      Shape( int a=0, int b=0)
      {
         width = a;
         height = b;
      }
      // 此处使用int area()  和 virtual int area() 的区别 
      {
         cout << "Parent class area :" <<endl;
         return 0;
      }
};
class Rectangle: public Shape{
   public:
      Rectangle( int a=0, int b=0):Shape(a, b) { }
      int area ()
      { 
         cout << "Rectangle class area :" <<endl;
         return (width * height); 
      }
};
class Triangle: public Shape{
   public:
      Triangle( int a=0, int b=0):Shape(a, b) { }
      int area ()
      { 
         cout << "Triangle class area :" <<endl;
         return (width * height / 2); 
      }
};

/*-----------------------------------------------------------------
// 输入：
// 输出：
// 功能描述：多态的测试代码
// 作者：MickelZhang
// 日期：2020/12/18
// 修改人：
// 记录：
// 修改人：
// 记录：
// 版本：
-----------------------------------------------------------------*/
void TestForShapePolymorphism()
{
   Shape *shape;
   Rectangle rec(10,7);
   Triangle  tri(10,5);
 
   // 存储矩形的地址
   shape = &rec;
   // 调用矩形的求面积函数 area
   shape->area();
 
   // 存储三角形的地址
   shape = &tri;
   // 调用三角形的求面积函数 area
   shape->area();
}

/*-----------------------------------------------------------------
// 功能描述：数据抽象，对外接口
// 用法：（也可以举例添加详细的使用方法，或者尽可能描述清楚）
// 作者：MickelZhang
// 日期：2020/12/18
// 修改人：MickelZhang 2020/12/12
// 记录：
// 修改人：
// 记录：
// 版本：
-----------------------------------------------------------------*/
class Adder{
   public:
      // 构造函数
      Adder(int i = 0)
      {
        total = i;
      }
      // 对外的接口
      void addNum(int number)
      {
          total += number;
      }
      // 对外的接口
      int getTotal()
      {
          return total;
      };
   private:
      // 对外隐藏的数据
      int total;
};

/*-----------------------------------------------------------------
// 输入：
// 输出：
// 功能描述：数据抽象的测试代码
// 作者：MickelZhang
// 日期：2020/12/18
// 修改人：
// 记录：
// 修改人：
// 记录：
// 版本：
-----------------------------------------------------------------*/
void TestForDataAbstract()
{
   Adder a;
   
   a.addNum(10);
   a.addNum(20);
   a.addNum(30);
 
   cout << "Total " << a.getTotal() <<endl;
   return 0;
}
